#! /usr/bin/env python

import numpy as np
import rospy
import cv2
from sensor_msgs.msg import Image
import sys
from cv_bridge import CvBridge, CvBridgeError
from IPython import embed
import copy

def callbackDepth(data):
	try:

		## First import data into array
		N = np.fromstring(data.data,dtype = np.float32)
		depth_array = np.reshape(N,(480,640))
		
		## Now correct for depth holes by assigning to the maximum value
		depth_array[np.isnan(depth_array)] = 0
		depth_array[depth_array==0] = depth_array.max()

		## Ideally now the blocks are almost black in the depth_array 
		depth_image = copy.deepcopy(depth_array)
		cv2.normalize(depth_image,depth_image, 0, 1, cv2.NORM_MINMAX)
		depth_detect = copy.deepcopy(depth_image)*0
		depth_detect[depth_image<0.3] = 1
		depth_image = cv2.cvtColor(depth_image,cv2.COLOR_GRAY2RGB)
		cv2.imshow("depth_image",depth_image)
		cv2.imshow("depth_detect",depth_detect)
		cv2.waitKey(1)

		## Blob detection
		depth_image = cv2.cvtColor(depth_image,cv2.COLOR_GRAY2RGB)
		blur_img = cv2.blur(depth_image,(5,5))
		contours,hierarchy = cv2.findContours(blur_img,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
		max_area_threshold = 10
		for cnt in contours:
			area = cv2.contourArea(cnt)
			M = cv2.moments(cnt)
			cx,cy = int(M['m10']/M['m00']), int(M['m01']/M['m00'])
			x,y,w,h = cv2.boundingRect(cnt)
			if area > max_area_threshold:
				cv2.rectangle(depth_image,(x,y),(x+w,y+h),255,2)
				cv2.circle(self.img,(cx,cy),10,255,-1)
		cv2.imshow("depth_image_detect",depth_image)
		cv2.waitKey(1)
		#cv2.imwrite('capture.png',depth_array)
	except CvBridgeError, e:
		print e
	
rospy.init_node('test_depth')
rospy.Subscriber('camera/depth/image',Image,callbackDepth)
rospy.spin()

